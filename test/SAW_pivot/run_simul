#
#    SAW_pivot implements the pivot algorithm for Monte Carlo simulations
#      of self-avoiding walks
#    Copyright (C) 2003 Tom Kennedy
#
#    This file is part of SAW_pivot (version 1.0).
#
#    SAW_pivot is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    SAW_pivot is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with SAW_pivot; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#    E-mail contact: tgk@math.arizona.edu
#    Ordinary mail: 
#	Tom Kennedy
#        Mathematics Department
#	University of Arizona
#	Tucson, ZA 85721, USA
#
#


# file: run_simul
# 
# script for showing how to run simul.c
# The script compiles the program and runs it.
# The parameters like length of the walk, type of lattice, ...
# are set in this script and may be changed here. 
# Documentation on these parameters follows. 

# The program simul.c computes the square of the end to end distance 
# of the walk. The program periodically writes an empirical mean of 
# this RV to the file "junk.dat."
# So junk.dat will contain a sequence of "batched means." 
# The program also periodically writes the walk to the file "walk.plt".

# 'algorithm' specifies both the number of dimensions and the lattice type
# The present options are 
# Two dimensions:
#  algorithm=7 : the square lattice with all lattice symmetries used.
#  algorithm=2 : the square lattice using only reflections in 45 deg lines
#  algorithm=1 : the Manhattan lattice
#  algorithm=5 : the hexagonal lattice
#  algorithm=11 : the triangular lattice
# Three dimensions:
#  algorithm=47 : the cubic lattice
# Four dimensions:
#  algorithm=383 : the hyper-cubic lattice
algorithm=7

# 'nsteps' is the number of steps in the walk. 
nsteps=10000

# 'region' determines the region the walk must lie in. 
# region=0: no restriction : all SAW starting at the origin
# region=1: half-plane or space: all SAW starting at the origin which 
#           satisfy y>0 for all other points on the walk.
# region=2: cut-plane or space: all SAW starting at the origin which 
#           satisfy y!=0 for all other points on the walk.
region=0

# interaction:
#    1 is the strictly SAW 
#    2 is the weakly SAW 
#    3 is the weakly SAW in which the penalty for self-intersection decays
#      as a negative power of the length of the loop. 
#    NB: 2 and 3 require additional parameters to be input. If you want to 
#      run one of these, you will need to look at simul.c to see how to 
#      modify this script
interaction=1

# nsimplify is how often we carry out the pivots that have been accepted 
# but not carried out yet. Setting it to 0 will make simul.c choose nsimplify.
nsimplify=0

# simul.c contains nested for loops. niter in the number of iterations 
# of the outer loop. The total number of attempted pivots is niter*INNER_LOOP
niter=10

# nrecord is the frequency (in terms of the outer loop) for recording the walk
nrecord=2

mv src/public/variable.h src/public/variable.h~ 

# simul.c contains nested for loops. INNER_LOOP in the number of iterations 
# for the inner loop. I always set it to one million.
echo "#define INNER_LOOP 1000000" > src/public/variable.h

# MAX_NPIVOT is used for memory allocation. nsimplify must be <= MAX_NPIVOT
echo "#define MAX_NPIVOT 1000" >> src/public/variable.h

# NO_SAW is usually 0; setting to 1 will simulate the ordinary random walk
echo "#define NO_SAW 0" >> src/public/variable.h

echo '#define ALGORITHM_NUMBER '$algorithm'' >> src/public/variable.h

# Each of the following two lines can be uncommented to implement 
# options that change how the pivot algorithm is implemented.
# They will not change the sequence of walks generated. Depending 
# on the parameters values they will make the program run slightly 
# faster or slower.
#
# echo "#define USE_THIRD" >> src/public/variable.h
# echo "#define USE_FIND_SEGMENT" >> src/public/variable.h

# PRINT_FREQ : how often we print stuff in terms of number of attempted pivots
echo "#define PRINT_FREQ 100000" >> src/public/variable.h

rm simul
rm junk.dat

make simul

rm junk.in

# The 0 below tells simul.c to generate a line for the initial walk
# If you want to read the initial walk from a file, replace 0 with 
# the name of the file. After this script runs there will be a file 
# named "junk" which contains the final walk of the simulation. It 
# could be used as the initial walk for another simulation. 
# The first line in the file contains two integers - the number of 
# steps in the walk and then the "age" of the walk. The age is the 
# number of iterations of the pivot algorithm in multiples of 
# INNER_LOOP and plays no role in the simulation. In the rest of the file,
# each line contains a d-tuple of integers representing the coordinates
# of a point, where d is the number of dimensions.
echo "0" >> junk.in

# this is the file the final walk will be stored in 
echo "junk" >> junk.in

# this is the file the data will be stored in 
echo "junk.dat" >> junk.in

# seed for the random number generator. A negative value will cause 
# simul.c to generate a seed using the system clock. 
echo "0" >> junk.in

echo ''$nsteps'' >> junk.in
echo ''$region'' >> junk.in
echo ''$interaction'' >> junk.in
echo ''$nsimplify'' >> junk.in
echo ''$niter'' >> junk.in
echo ''$nrecord'' >> junk.in

time simul < junk.in 


